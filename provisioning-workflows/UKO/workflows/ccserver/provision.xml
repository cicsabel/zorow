<?xml version="1.0" encoding="UTF-8"?>

<!-- Declare external file containing WAS variables referenced in the following steps -->
<!DOCTYPE workflow [<!ENTITY variables SYSTEM "variable_imports.xml">
                    <!ENTITY image_properties SYSTEM "extensions/image_properties.xml">
                    ]> 
                    
<!--
/******************************************************************************/
/* Copyright Contributors to the zOS-Workflow Project.                        */
/* SPDX-License-Identifier: Apache-2.0                                        */
/******************************************************************************/
-->
<workflow xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../workflow/schemas/workflow_v1.xsd">
    <!--  Note: The schema workflow_v1.xsd is shipped with z/OSMF. To use the schema
          to validate this XML, modify the above schema location to point to the 
          schema in z/OSMF, or copy the schema to an appropriate location.  -->

    <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Provisioning : Provision a new server                                -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

  <workflowInfo>
      <workflowID>cc_Provision</workflowID>
      <workflowDescription>Provision a server.</workflowDescription>
    <workflowVersion>1.0.0.0</workflowVersion>
        <!-- Build timestamp 2021.05.09.21.03.24 -->
      <vendor>IBM</vendor>
      <Provisioning>
          <productID>5655-EKM</productID>
          <productName>UKO</productName>
          <productVersion>V2R1+</productVersion>
          <softwareType>ccserver</softwareType>
      </Provisioning>
  </workflowInfo>
  
  	<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
	<!--     Include variables used by the following steps     -->
	<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
	&variables;

    &image_properties;
    
    <!--++++++++++++++++++++++-->
    <!--   Provision Steps    -->
    <!--++++++++++++++++++++++-->  

    <step name="createDirectories">
        <title>Create and mount directories</title>
        <description>Create the directories required by the new server</description>

        <step name="createServerDir">
            <title>Create server directory</title>
            <description>Submit script to create the server directory</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <variableValue name="WLP_USER_DIR" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">
                                                
                    if [ ! -d "${instance-WLP_USER_DIR}/servers/" ]; then
                        mkdir -p ${instance-WLP_USER_DIR}/servers/
                        if [ $? -gt 0 ]; then 
                            echo "ERROR: Could not create directory" >&amp;2;
                            exit "2"; 
                        fi
                    fi

                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
            </template>
        </step>

        <step name="createZFS">
            <title>Create zFS datasets</title>
            <description>If requested, create and mount a new ZFS</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_ZFS}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_ZFS}</approver>
            <variableValue name="CC_SERVER_STC_NAME" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="WLP_USER_DIR" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="ZOS_VSAM_VOLUME" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="ZOS_ZFS_DATACLASS" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_FILE_SYSTEM_HLQ" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="WLP_OUTPUT_DIR" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit JCL to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
            <fileTemplate substitution="true">jcl/create-zfs.jcl</fileTemplate>
            <submitAs>JCL</submitAs>
            </template>
        </step>
        
        <step name="MountZFS" optional="false">
            <title>Mount zFS filesystem</title>
            <description>This step runs a script to mount the zFS dataset within the directory specified by the templates WLP_USER_DIR property. The job is run under the userid specified by the templates CC_ADMIN_ZFS property.</description>
            <prereqStep name="createZFS"/>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_ZFS}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_ZFS}</approver>
            <instructions>Execute the mount zFS script to mount the zFS dataset (MountZFS.script)</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">scripts/mount-zfs.script</fileTemplate>
                <submitAs>shell-JCL</submitAs>
            </template>
        </step>
        

    </step>
	
    <step name="configureDefaultServer">
        <title>Configure the default server</title>
        <description>Configure the default Liberty server with only the default config dropin files</description>

        <step name="substituteServerEnv">
		    <title>Substitute server.env</title>
	        <description>replace values in server.env with template variable values</description>
	        <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
	        <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <variableValue name="JAVA_HOME" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_TLS_KEY_STORE_KEY_RING" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_TLS_TRUST_STORE_KEY_RING" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_TLS_KEY_STORE_SERVER_CERT" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_HTTP_PORT" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_HTTPS_PORT" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_UNAUTHENTICATED_USER" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="SAF_PROFILE_PREFIX" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_OAUTH_CLIENT_ID" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_OAUTH_CLIENT_ID_OPENAPI" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_OIDC_PROVIDER_CERT" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">

                #if(${instance-CC_TRACE_OPTIONS} &amp;&amp; ${instance-CC_TRACE_OPTIONS} != "")
                    # removing potential quotes
                    traceoptions=$(echo "${instance-CC_TRACE_OPTIONS}" | sed 's/\"//g')
                #end
                
                sedstring="s#JAVA_HOME=.*#JAVA_HOME=${instance-JAVA_HOME}#g;"
                #if(${instance-WLP_OUTPUT_DIR} &amp;&amp; ${instance-WLP_OUTPUT_DIR} != "")
                    sedstring="${sedstring} s#^[ \#]*WLP_OUTPUT_DIR=.*#WLP_OUTPUT_DIR=${instance-WLP_OUTPUT_DIR}#g;"
                #end
                #if(${instance-ENABLE_MTLS_VIA_HTTPS_PORT} &amp;&amp; ${instance-ENABLE_MTLS_VIA_HTTPS_PORT} != "")
                    sedstring="${sedstring} s#^[ \#]*TLS_CLIENT_AUTHENTICATION_SUPPORTED=.*#TLS_CLIENT_AUTHENTICATION_SUPPORTED=${instance-ENABLE_MTLS_VIA_HTTPS_PORT}#g;"
                #end
                #if(${instance-CC_TRACE_OPTIONS} &amp;&amp; ${instance-CC_TRACE_OPTIONS} != "")
                    sedstring="${sedstring} s#^[ \#]*TRACE_SPEC=.*#TRACE_SPEC=\"${traceoptions}\"#g;"
                #end
                sedstring="${sedstring} s#^[ \#]*TLS_KEY_STORE_KEY_RING=.*#TLS_KEY_STORE_KEY_RING=${instance-CC_TLS_KEY_STORE_KEY_RING}#g;"
                sedstring="${sedstring} s#^[ \#]*TLS_TRUST_STORE_KEY_RING=.*#TLS_TRUST_STORE_KEY_RING=${instance-CC_TLS_TRUST_STORE_KEY_RING}#g;"
                sedstring="${sedstring} s#^[ \#]*TLS_KEY_STORE_SERVER_CERT=.*#TLS_KEY_STORE_SERVER_CERT=${instance-CC_TLS_KEY_STORE_SERVER_CERT}#g;"
                sedstring="${sedstring} s#^[ \#]*HTTP_PORT=.*#HTTP_PORT=${instance-CC_HTTP_PORT}#g;"
                sedstring="${sedstring} s#^[ \#]*HTTPS_PORT=.*#HTTPS_PORT=${instance-CC_HTTPS_PORT}#g;"
                sedstring="${sedstring} s#^[ \#]*SAF_UNAUTHENTICATED_USER_ID=.*#SAF_UNAUTHENTICATED_USER_ID=${instance-CC_UNAUTHENTICATED_USER}#g;"
                sedstring="${sedstring} s#^[ \#]*SAF_PROFILE_PREFIX=.*#SAF_PROFILE_PREFIX=${instance-SAF_PROFILE_PREFIX}#g;"
                sedstring="${sedstring} s#^[ \#]*EKMF_OAUTH_CLIENT_ID=.*#EKMF_OAUTH_CLIENT_ID=${instance-CC_OAUTH_CLIENT_ID}#g;"
                sedstring="${sedstring} s#^[ \#]*EKMF_OAUTH_CLIENT_ID_OPENAPI=.*#EKMF_OAUTH_CLIENT_ID_OPENAPI=${instance-CC_OAUTH_CLIENT_ID_OPENAPI}#g;"
                sedstring="${sedstring} s#^[ \#]*OIDC_PROVIDER_TRUST_ALIAS_NAME=.*#OIDC_PROVIDER_TRUST_ALIAS_NAME=${instance-CC_OIDC_PROVIDER_CERT}#g;"
                sedstring="${sedstring} s#^[ \#]*OIDC_PROVIDER_KEY_ALIAS_NAME=.*#OIDC_PROVIDER_KEY_ALIAS_NAME=${instance-CC_OIDC_PROVIDER_CERT}#g" 
                
                sed -e "$sedstring" ${instance-CC_INSTALL_DIR}/server.env > ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/server.env;
                                          
                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
                <maxLrecl>2048</maxLrecl>
            </template>
        </step>

        <step name="substituteJvmOptions">
		    <title>Substitute jvm.options</title>
	        <description>replace values in jvm.options with template variable values</description>
	        <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
	        <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <variableValue name="WLP_ANGEL_NAME" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
   		         <inlineTemplate substitution="true">
                    sed "s#-Djava.util.prefs.userRoot=.*#-Djava.util.prefs.userRoot=${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/preferences#g;
                        #if(${instance-WLP_ANGEL_NAME} &amp;&amp; ${instance-WLP_ANGEL_NAME} != "")
                            s#^[ \#]*-Dcom.ibm.ws.zos.core.angelName=.*#-Dcom.ibm.ws.zos.core.angelName=${instance-WLP_ANGEL_NAME}#g;
                        #end
                        s#^[ \#]*-Ddb2.jcc.ssid=.*#-Ddb2.jcc.ssid=${instance-DB_JCC_SSID}#g" ${instance-CC_INSTALL_DIR}/jvm.options > ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/jvm.options;
             	 </inlineTemplate>
            	<submitAs>shell-JCL</submitAs>
        	</template>
        </step>

        <step name="setDirectoryPermissions">
            <title>Set Directory Permissions</title>
            <description>Remove read and execute access for all users to the zFS file system and set group access if required</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <variableValue name="CC_SERVER_STC_USER" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_SERVER_STC_GROUP" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Remove access to all users from ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
              <inlineTemplate substitution="true">
    
                #if(${instance-WLP_OUTPUT_DIR} != "" &amp;&amp; ${instance-WLP_OUTPUT_DIR})
                    echo "Ensure read and write access to ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME}"
                    chmod -R u+rw ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME}
                    echo "Changing ownership of ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME}"
                    #if(${instance-CC_SERVER_STC_GROUP} != "" &amp;&amp; ${instance-CC_SERVER_STC_GROUP})               
                        chown -R ${instance-CC_SERVER_STC_USER}:${instance-CC_SERVER_STC_GROUP} ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME}
                    #else
                        chown -R ${instance-CC_SERVER_STC_USER} ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME}
                    #end
                #end

                #if(${instance-CC_SERVER_STC_GROUP} != "" &amp;&amp; ${instance-CC_SERVER_STC_GROUP})
                    echo "Transfer ownership of ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME} to ${instance-CC_SERVER_STC_USER} : ${instance-CC_SERVER_STC_GROUP}"
                    chown -R ${instance-CC_SERVER_STC_USER}:${instance-CC_SERVER_STC_GROUP} ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                    echo "Change access of ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME} to 750"
                    chmod -R 750 ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                #else
                    echo "Transfer ownership of ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME} to ${instance-CC_SERVER_STC_USER}"
                    chown -R ${instance-CC_SERVER_STC_USER} ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                    echo "Change access of ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME} to 700"
                    chmod -R 700 ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                #end
    
                if [ $? -eq 1 ]; then 
                    echo "chmod returned 1"
                    echo "Verify if this is due to CC_INSTALL_DIR read-only".
                fi
                if [ $? -gt 1 ]; then 
                    echo "ERROR: Could not chmod directory" >&amp;2;
                    exit "8"; 
                fi
    
              </inlineTemplate>
              <submitAs>shell-JCL</submitAs>
               </template>
        </step>

        <step name="createSymLinks">
            <title>Create SymLinks to install directory</title>
            <description>Submit script to create symbolig links to the server installation diretory. </description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">

                    # Create symlinks to the installation folder 
                    cd ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                    echo "creating symlink to ${instance-CC_INSTALL_DIR}/EkmfWeb.properties"
                    ln -s ${instance-CC_INSTALL_DIR}/EkmfWeb.properties EkmfWeb.properties
                    echo "creating symlink to ${instance-CC_INSTALL_DIR}/apps"
                    ln -s ${instance-CC_INSTALL_DIR}/apps apps

                    if [ -d "${instance-CC_INSTALL_DIR}/includes" ] 
                    then
                        echo "creating symlink to ${instance-CC_INSTALL_DIR}/includes"
                        ln -s ${instance-CC_INSTALL_DIR}/includes includes; 
                    fi

                    echo "creating symlink to ${instance-CC_INSTALL_DIR}/resources"
                    ln -s ${instance-CC_INSTALL_DIR}/resources resources
                    echo "creating symlink to ${instance-CC_INSTALL_DIR}/server.xml"
                    ln -s ${instance-CC_INSTALL_DIR}/server.xml server.xml			    

                    #if(${instance-WLP_OUTPUT_DIR} != "" &amp;&amp; ${instance-WLP_OUTPUT_DIR})
                        echo "Creating a symlink to the ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME} output directory for convenience"
                        ln -s ${instance-WLP_OUTPUT_DIR}/${instance-CC_SERVER_STC_NAME} output
                    #end

                    if [ -d "${instance-CC_INSTALL_DIR}/configDropins" ] 
                    then
                        echo "configDropins folder found in ${instance-CC_INSTALL_DIR}"
                        echo "creating ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/configDropins"
                        mkdir configDropins
                        echo "creating ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/configDropins/overrides"
                        mkdir configDropins/overrides
                        
                        echo "creating symlinks to the configDropins folder"

                        echo "creating symlink to ${instance-CC_INSTALL_DIR}/configDropins/defaults"
                        ln -s ${instance-CC_INSTALL_DIR}/configDropins/defaults configDropins/defaults

                        echo "creating symlink to ${instance-CC_INSTALL_DIR}/configDropins/options"
                        ln -s ${instance-CC_INSTALL_DIR}/configDropins/options configDropins/options

                        chown ${instance-CC_SERVER_STC_USER} configDropins
                        chown ${instance-CC_SERVER_STC_USER} configDropins/overrides

                        echo "Finished setting up configDropins:"
                        ls -al configDropins/
                    fi  
                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
            </template>
        </step>

    </step>

    <step name="configureMsdke">
        <title>Configure MSDKE Support</title>
        <description>Configure the new server for Microsoft Double Key Encryption</description>

        <step name="substituteServerEnvMsdke">
		    <title>Substitute server.env MSDKE parameters</title>
	        <description>Configure server.env with the specified MSDKE parameters</description>
	        <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
	        <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <condition>
                <expression>"1"=="1"</expression>
                <description>always true</description>
                <targetStateSet>
                    <description>Only execute for MSDKE configuration</description>
                    <extendStateExpression>
                        <description>Skip if no MSDKE configuration is required</description>
                        <expression>${instance-MSDKE_SUPPORT_REQUIRED}  == "false"</expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <variableValue name="DB_LOCATION" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="DB_CURRENT_SCHEMA" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="DB_LIBPATH" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="DB_CLASSPATH" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="MSDKE_RABBIT_URI" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="MSDKE_RABBIT_VIRTUAL_HOST" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="MSDKE_WRAPPING_KEK_LABEL" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="MSDKE_EC_IDENTITY_KEY_LABEL" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="MSDKE_EC_TRUSTED_KEYS_X509_ENCODED" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">

                    cd ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                    mv ./server.env ./server.env.original
                    if [ $? -gt 0 ]; then 
                        echo "ERROR: Original server.env not found, make sure you executed base setup";
                        exit "8"; 
                    fi                      
      
                    sedstring="s#^[ \#]*EKMF_API_DB_NAME=.*#EKMF_API_DB_NAME=${instance-DB_LOCATION}#g;"
                    sedstring="${sedstring} s#^[ \#]*DB_CURRENT_SCHEMA=.*#DB_CURRENT_SCHEMA=${instance-DB_CURRENT_SCHEMA}#g;"
                    sedstring="${sedstring} s#^[ \#]*DB_LIBPATH=.*#DB_LIBPATH=${instance-DB_LIBPATH}#g;"
                    sedstring="${sedstring} s#^[ \#]*DB_CLASSPATH=.*#DB_CLASSPATH=${instance-DB_CLASSPATH}#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_RABBIT_URI=.*#MSDKE_RABBIT_URI=${instance-MSDKE_RABBIT_URI}#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_RABBIT_VIRTUAL_HOST=.*#MSDKE_RABBIT_VIRTUAL_HOST=${instance-MSDKE_RABBIT_VIRTUAL_HOST}#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_EC_IDENTITY_KEY_LABEL=.*#MSDKE_EC_IDENTITY_KEY_LABEL=${instance-MSDKE_EC_IDENTITY_KEY_LABEL}#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_WRAPPING_KEK_LABEL=.*#MSDKE_WRAPPING_KEK_LABEL=${instance-MSDKE_WRAPPING_KEK_LABEL}#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_RABBIT_ENABLE_CERT_AUTHENTICATION=.*#MSDKE_RABBIT_ENABLE_CERT_AUTHENTICATION=true#g;"
                    sedstring="${sedstring} s#^[ \#]*MSDKE_EC_TRUSTED_KEYS_X509_ENCODED=.*#MSDKE_EC_TRUSTED_KEYS_X509_ENCODED=${instance-MSDKE_EC_TRUSTED_KEYS_X509_ENCODED}#g"
                    sed -e "$sedstring" ./server.env.original > ./server.env

                    # temporary addition until parameter is present in server.env
                    echo "MSDKE_RABBIT_ENABLE_CERT_AUTHENTICATION=true" >> ./server.env

                    #if(${instance-CC_SERVER_STC_GROUP} != "" &amp;&amp; ${instance-CC_SERVER_STC_GROUP})
                        echo "Transfer ownership of new server.env to ${instance-CC_SERVER_STC_USER} : ${instance-CC_SERVER_STC_GROUP}"
                        chown ${instance-CC_SERVER_STC_USER}:${instance-CC_SERVER_STC_GROUP} ./server.env
                        echo "Change access of new server.env to 750"
                        chmod 750 ./server.env
                    #else
                        echo "Transfer ownership of new server.env to ${instance-CC_SERVER_STC_USER}"
                        chown ${instance-CC_SERVER_STC_USER} ./server.env
                        echo "Change access of new server.env to 700"
                        chmod 700 ./server.env
                    #end

                    rm ./server.env.original
                          
                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
                <maxLrecl>2048</maxLrecl>
            </template>
        </step>

        <step name="loadConfigDropinsMSDKE">
            <title>Load MSDKE configDropins</title>
            <description>Configure the configDropins folder to load the MSDKE related code</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <condition>
                <expression>"1"=="1"</expression>
                <description>always true</description>
                <targetStateSet>
                    <description>Only execute for MSDKE configuration</description>
                    <extendStateExpression>
                        <description>Skip if no MSDKE configuration is required</description>
                        <expression>${instance-MSDKE_SUPPORT_REQUIRED}  == "false"</expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">

                    cd ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}

                    echo "linking msdke-crypto-service.xml into overrides folder"
                    ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/msdke-crypto-service.xml configDropins/overrides/msdke-crypto-service.xml
                    echo "linking db2-zos-type2.xml into overrides folder"
                    ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/db2-zos-type2.xml configDropins/overrides/db2-zos-type2.xml

                    if [ -f ${instance-CC_INSTALL_DIR}/configDropins/options/msdke-http-testing-service.xml ]; then
                        echo "testing service msdke-http-testing-service.xml found, linking into overrides"
                        ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/msdke-http-testing-service.xml configDropins/overrides/msdke-http-testing-service.xml
                    fi

                    chown ${instance-CC_SERVER_STC_USER} configDropins
                    chown ${instance-CC_SERVER_STC_USER} configDropins/overrides

                    echo "Finished setting up configDropins:"
                    ls -al configDropins/overrides

                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
            </template>
        </step>

        <step name="configureHttpService">
            <title>(Optional) Configure internal MSDKE HTTP service for test</title>
            <description>Enable the integrated test HTTP service for MSDKE, ote that this is not recommended for production</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
            <condition>
                <expression>"1"=="1"</expression>
                <description>always true</description>
                <targetStateSet>
                    <description>Only execute if required</description>
                    <extendStateExpression>
                        <description>Skip if no MSDKE HTTP service is required</description>
                        <expression>${instance-MSDKE_ENABLE_HTTP_SERVICE}  == "false"</expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <instructions substitution="true">Submit shell script to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">

                    cd ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}

                    echo "linking msdke-http-service.xml into overrides folder"
                    ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/msdke-http-service.xml configDropins/overrides/msdke-http-service.xml

                    chown ${instance-CC_SERVER_STC_USER} configDropins
                    chown ${instance-CC_SERVER_STC_USER} configDropins/overrides

                    echo "Finished setting up configDropins:"
                    ls -al configDropins/overrides

                </inlineTemplate>
                <submitAs>shell-JCL</submitAs>
            </template>
        </step>        

        <step name="configureDatabaseAccess">
            <title>Configure access to the UKO Server key database</title>
            <description>Configure the new server to be able to access the required view in a UKO instance</description>        
            <runAsUser substitution="true">$!{instance-CC_ADMIN_DB}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_DB}</approver>
            <condition>
                <expression>"1"=="1"</expression>
                <description>always true</description>
                <targetStateSet>
                    <description>Only execute for MSDKE configuration</description>
                    <extendStateExpression>
                        <description>Skip if no MSDKE configuration is required</description>
                        <expression>${instance-MSDKE_SUPPORT_REQUIRED}  == "false"</expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <variableValue name="CC_SERVER_STC_USER" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="DB_CURRENT_SQLID" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="DB_CURRENT_SCHEMA" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit jcl to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">jcl/database-grant-access.jcl</fileTemplate>
                <submitAs maxRc="8">JCL</submitAs>
                <maxLrecl>80</maxLrecl>
            </template>
        </step>

    </step>

    <step name="loadConfigDropinsCryptoConnect">
        <title>Load Crypto Connect configDropins</title>
        <description>Configure the configDropins folder to load the Crypto Connect related code</description>
        <runAsUser substitution="true">$!{instance-CC_ADMIN_SERVER}</runAsUser>
        <approver substitution="true">$!{instance-CC_APPROVER_SERVER}</approver>
        <condition>
            <expression>"1"=="1"</expression>
            <description>always true</description>
            <targetStateSet>
                <description>Only execute for Crypto Connect configuration</description>
                <extendStateExpression>
                    <description>Skip if no Crypto Connect configuration is required</description>
                    <expression>${instance-CRYPTO_CONNECT_SUPPORT_REQUIRED}  == "false"</expression>
                    <targetState>Skipped</targetState>
                </extendStateExpression>
            </targetStateSet>
        </condition>
        <instructions substitution="true">Submit shell script to execute step</instructions>
        <weight>1</weight>
        <autoEnable>true</autoEnable>
        <template>
            <inlineTemplate substitution="true">

                cd ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}

                echo "linking crypto-connect-core.xml into overrides folder"
                ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/crypto-connect-core.xml configDropins/overrides/crypto-connect-core.xml
                echo "linking open-id-provider.xml into overrides folder"
                ln -s ${instance-CC_INSTALL_DIR}/configDropins/options/open-id-provider.xml configDropins/overrides/open-id-provider.xml

                chown ${instance-CC_SERVER_STC_USER} configDropins
                chown ${instance-CC_SERVER_STC_USER} configDropins/overrides

                echo "Finished setting up configDropins:"
                ls -al configDropins/overrides

            </inlineTemplate>
            <submitAs>shell-JCL</submitAs>
        </template>
    </step>

    <step name="createServerProc">
        <title>Create Server Proc</title>
        <description>Create the server proc</description>
           <runAsUser substitution="true">$!{instance-CC_ADMIN_TSO}</runAsUser>
           <approver substitution="true">$!{instance-CC_APPROVER_TSO}</approver>
        <variableValue name="ZOS_PROCLIB" scope="instance" noPromptIfSet="false" required="false"/>
        <instructions substitution="true">Submit JCL to execute step</instructions>
        <weight>5</weight>
        <autoEnable>true</autoEnable>
        <template>
           <fileTemplate substitution="true">jcl/create-server-proc.jcl</fileTemplate>
           <submitAs>JCL</submitAs>
           <maxLrecl>80</maxLrecl>
      </template>
    </step>

    <step name="configureSecurity">
    	<title>Configure security for the server</title>
    	<description>Configure security for the server and related resources</description>

        <step name="configureSAFSecurityProfiles">
            <title>Configure SAF Security</title>
            <description>Configure the new server for z/OS authentication to the angel</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SECURITY}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SECURITY}</approver>
            <variableValue name="CC_SERVER_STC_USER" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_SERVER_STC_GROUP" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_UNAUTHENTICATED_USER" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="CC_UNAUTHENTICATED_GROUP" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions substitution="true">Submit rexx exec to execute step</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">extensions/defineSecurity.rexx</fileTemplate>
                <submitAs maxRc="0">TSO-REXX-JCL</submitAs>
                <maxLrecl>1024</maxLrecl>
            </template>
        </step>

        <step name="defineIcsfAccess">
            <title>Define access to ICSF</title>
            <description>Define the profiles in the CSFSERV class and grant access</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SECURITY}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SECURITY}</approver>
            <instructions>Executes a REXX program to create profiles and grant access</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">extensions/defineIcsfAccess.rexx</fileTemplate>
                <submitAs maxRc="4">TSO-REXX-JCL</submitAs>
                <maxLrecl>1024</maxLrecl>
            </template>
        </step>

        <step name="defineKeyAccess">
            <title>Define access to keys in CSFKEYS</title>
            <description>Create entry in CSFKEYS class and grant access</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SECURITY}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SECURITY}</approver>
            <variableValue name="CC_KEY_PREFIX" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions>Executes a REXX program to create the key prefix</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">extensions/defineKeyAccess.rexx</fileTemplate>
                <submitAs maxRc="4">TSO-REXX-JCL</submitAs>
                <maxLrecl>1024</maxLrecl>
            </template>
        </step>

        <step name="defineCryptoConnectAccess">
            <title>Define roles and access for Crypto Connect</title>
            <description>Define the EJBROLE profiles to run Crypto Connect</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_SECURITY}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_SECURITY}</approver>
            <condition>
                <expression>"1"=="1"</expression>
                <description>always true</description>
                <targetStateSet>
                    <description>Only execute for Crypto Connect configuration</description>
                    <extendStateExpression>
                        <description>Skip if no Crypto Connect configuration is required</description>
                        <expression>${instance-CRYPTO_CONNECT_SUPPORT_REQUIRED}  == "false"</expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <variableValue name="CRYPTO_CONNECT_USER_GROUP" scope="instance" noPromptIfSet="false" required="false"/>
            <variableValue name="SAF_PROFILE_PREFIX" scope="instance" noPromptIfSet="false" required="false"/>        
            <instructions>Executes a REXX program to create EJB roles and grant access</instructions>
            <weight>1</weight>
            <autoEnable>true</autoEnable>
            <template>
                <fileTemplate substitution="true">extensions/defineAccessCryptoConnect.rexx</fileTemplate>
                <submitAs maxRc="4">TSO-REXX-JCL</submitAs>
                <maxLrecl>1024</maxLrecl>
            </template>
        </step>
          
	</step>

  
    <step name="startServer">
        <title>Start the server</title>
        <description>Start the server</description>

        <step name="validateConsoleAPI" optional="false">
            <title>Validating console commands can be issued</title>
            <description>Issue a command via the console API to ensure basic commands can be executed.</description>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_CONSOLE}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_CONSOLE}</approver>
            <condition>
                <expression><![CDATA["1" == "1"]]></expression>
                <description>Should the step be executed, based on the START_SERVER setting</description>
                <targetStateSet>
                  <description/>
                    <extendStateExpression>
                        <description>Skip if START_SERVER == false</description>
                        <expression><![CDATA[ ${instance-START_SERVER} == "false"]]></expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
                </targetStateSet>
            </condition>
            <variableValue name="CC_SERVER_STC_NAME" scope="instance" noPromptIfSet="false" required="false"/>
            <instructions>Execute console API to check if its set up correctly</instructions>
            <weight>1</weight>
            <skills>z/OS administration</skills>
            <autoEnable>true</autoEnable>
            <rest>
                <httpMethod>PUT</httpMethod>
                <uriPath substitution="true">/zosmf/restconsoles/consoles/defcn</uriPath>
                <requestBody substitution="true">
                    { 
                      "cmd" : "d a,${instance-CC_SERVER_STC_NAME}",
                      "sol-key" : "NOT FOUND",
                      "system" : "${_workflow-systemName}"
                      
                    }
                </requestBody>
                <expectedStatusCode>200</expectedStatusCode>
                <propertyMapping mapTo="CC_REST_STATUS">["sol-key-detected"]</propertyMapping>
            </rest>
        </step>
    
        <step name="startServer_console">
        	<title>Start the server from console</title>
        	<description>Start the server from the console</description>
        	<runAsUser substitution="true">$!{instance-CC_ADMIN_CONSOLE}</runAsUser>
	        <approver substitution="true">$!{instance-CC_APPROVER_CONSOLE}</approver>
	        <condition>
      			<expression><![CDATA["1" == "1"]]></expression>
				<description>Should the step be executed, based on the START_SERVER setting</description>
				<targetStateSet>
					<description/>
	      			<extendStateExpression>
	      				<description>Skip if START_SERVER == false</description>
	            		<expression><![CDATA[ ${instance-START_SERVER} == "false"]]></expression>
	      				<targetState>Skipped</targetState>
	      			</extendStateExpression>
				</targetStateSet>
			</condition>
     		<instructions substitution="false">Submitting script to stop the server.</instructions>
        	<weight>1</weight>
        	<autoEnable>true</autoEnable>
        	<rest>
				<httpMethod>PUT</httpMethod>
				<uriPath substitution="true">/zosmf/restconsoles/consoles/defcn</uriPath>
				<requestBody substitution="true">
				  {
				    "cmd" : "START ${instance-CC_SERVER_STC_NAME},PARMS='${instance-CC_SERVER_STC_NAME}'",
				    "unsol-key" : "CWWKF0011I: The ${instance-CC_SERVER_STC_NAME} server is ready",
                    "unsol-detect-sync" : "Y",
				    "unsol-detect-timeout" : "120",
				    "detect-time" : "120",
				    "system" : "${_workflow-systemName}"
				    
				  }	
				</requestBody>
				<expectedStatusCode>200</expectedStatusCode>
				<propertyMapping mapTo="CC_REST_STATUS">["status"]</propertyMapping>
			</rest>
    	</step>
    	
    	<step name="CheckStartup" optional="false">
            <title>Checking the rest status from the start command</title>
            <description>Check the REST Status from the start command</description>
            <prereqStep name="startServer_console"/>
            <runAsUser substitution="true">$!{instance-CC_ADMIN_TSO}</runAsUser>
            <approver substitution="true">$!{instance-CC_APPROVER_TSO}</approver>
            <condition>
                <expression><![CDATA[${startServer_console.stepState} == "Complete" || ${startServer_console.stepState} == "Skipped"]]></expression>
                <description>Should the step be executed based on the CC_REST_STATUS setting</description>
                <targetStateSet>
                    <description>Check to see whether this step should be skipped</description>
                    <extendStateExpression>
                        <description>Only execute it CC_REST_STATUS is not detected</description>
                        <expression><![CDATA[ ${instance-CC_REST_STATUS} == "detected"]]></expression>
                        <targetState>Skipped</targetState>
                    </extendStateExpression>
	      			<extendStateExpression>
	      				<description>Skip if START_SERVER == false</description>
	            		<expression><![CDATA[ ${instance-START_SERVER} == "false"]]></expression>
	      				<targetState>Skipped</targetState>
	      			</extendStateExpression>
                </targetStateSet>
            </condition>
            <instructions>Execute simple Rexx command to always return a bad returncode</instructions>
            <weight>1</weight>
            <skills>z/OS Administration</skills>
            <autoEnable>true</autoEnable>
            <template>
                <inlineTemplate substitution="true">
                    exit 8
                </inlineTemplate>
                <submitAs maxRc="0">TSO-REXX-JCL</submitAs>
            </template>
        </step> 
    </step>

    <step name="setMoreVariables" optional="false">
        <title>Set remaining variable names</title>
        <description>Set the remaining variable values</description>
        <runAsUser substitution="true">$!{instance-CC_ADMIN_ZFS}</runAsUser>
        <approver substitution="true">$!{instance-CC_APPROVER_ZFS}</approver>
        <instructions substitution="true">Submit shell script to execute step</instructions>
        <weight>1</weight>
        <autoEnable>true</autoEnable>
        <template>
            <inlineTemplate substitution="true">
                # Create a properties file with useful user information

                host=$(hostname | tr [:upper:] [:lower:])
                if [ $? -gt 0 ]; then
                    echo "ERROR: Could not query hostname" >&amp;2;
                    exit "11"; 
                fi
                echo "CC_ADDRESS https://$host:${instance-CC_HTTPS_PORT}" >> ${instance-TEMP_DIR}/${instance-CC_SERVER_STC_NAME}
                if [ $? -gt 0 ]; then 
                    echo "ERROR: Could not create properties file" >&amp;2;
                    exit "7"; 
                fi 

                currentversion=$(iconv -t IBM037 -f utf-8 ${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}/EkmfWeb.properties | grep com.ibm.websphere.productVersion | sed -E 's/.*=([^\$])/\1/')

                echo "CC_SERVER_VERSION $currentversion" >> ${instance-TEMP_DIR}/${instance-CC_SERVER_STC_NAME}

                serverdirectory=${instance-WLP_USER_DIR}/servers/${instance-CC_SERVER_STC_NAME}
                echo "CC_SERVER_DIRECTORY $serverdirectory" >> ${instance-TEMP_DIR}/${instance-CC_SERVER_STC_NAME}

            </inlineTemplate>
            <submitAs>shell-JCL</submitAs>
            <output substitution="true" needResolveConflicts="false">${instance-TEMP_DIR}/${instance-CC_SERVER_STC_NAME}</output>
        </template>
    </step>


</workflow>
